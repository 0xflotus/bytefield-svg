= Functions
James Elliott <james@deepsymmetry.org>
:icons: font
:toc: preamble
:experimental:

This section describes the drawing functions that are the main purpose
of `bytefield-svg`. They are designed to flexibly draw the elements
you might need in a byte field diagram. But they are also intended to
be combined with the functions in the Clojure
https://clojure.github.io/clojure/[core library], and you can dive
down to the https://github.com/liebke/analemma[Analemma SVG building
functions] used by these functions if you need to draw something
unique.

> TODO: Consider providing some basic documentation for the Analemma
  functions we export because the Analemma site is cryptic and
  currently has broken links to the source.

[[append-svg]]
== append-svg

NOTE: Most people will not need to use this function.

Adds an element to the end of the SVG document being created.

.Arguments
[source,clojure]
----
[element]
----

This function is only needed if you are using the lower-level
https://github.com/liebke/analemma/blob/master/src/analemma/svg.cljc[Analemma
SVG functions] to draw custom SVG content. Call this function with the
Clojure data structure returned by the SVG function and it will become
part of the diagram.

It’s beyond the current scope of these instructions to try to explain
Analemma, so you will need to study its own documentation and source
if you want to engage in this kind of low-level drawing. But as a
small example, you could draw a circle at coordinates (20, 10) with
radius 5 by calling:

[source,clojure]
(append-svg (svg/circle 20 10 5))

The `analemma.svg` functions available in `bytefield-svg` are all
organized under the `svg` namespace alias, and include:
`svg/add-style`, `svg/animate`, `svg/animate-color`,
`svg/animate-motion`, `svg/animate-transform`, `svg/circle`,
`svg/defs`, `svg/draw`, `svg/ellipse`, `svg/group`, `svg/image`,
`svg/line`, `svg/parse-inline-css`, `svg/path`, `svg/polygon`,
`svg/rect`, `svg/rgb`, `svg/rotate`, `svg/style`, `svg/style-map`,
`svg/svg`, `svg/text`, `svg/text-path`, `svg/transform`,
`svg/translate`, `svg/translate-value`, `svg/tref`, and `svg/tspan`.

You can also manipulate the
https://github.com/weavejester/hiccup[hiccup-like] structures returned
by these functions using the even-lower level
https://github.com/liebke/analemma/blob/master/src/analemma/xml.cljc[Analemma
XML functions]. These are organized under the `xml` namespace alias,
and include: `xml/add-attrs`, `xml/add-content`, `xml/emit`,
`xml/emit-attrs`, `xml/emit-tag`, `xml/get-attrs`, `xml/get-content`,
`xml/get-name`, `xml/has-attrs?`, `xml/has-content?`,
`xml/merge-attrs`, `xml/set-attrs`, `xml/set-content`, and
`xml/update-attrs`.

If you understand the structures built and used by Analemma, you can
also build them directly yourself and pass them to `append-svg`.

[[defattrs]]
== defattrs

Register a attribute map for later use in your diagram.

.Arguments
[source,clojure]
----
[k m]
----

TIP: By convention, in Clojure arguments, `k` means “a keyword” and
`m` means “a map”.

To add a new named attribute or update one of the
<<attrs#predefined-attributes,predefined attributes>>, pass the
keyword you want to define as the first argument, and the map of
attributes that you want that keyword to represent as the second
argument.

For example, if you want to have some of your byte boxes have a green
background, you could make `:bg-green` a named attribute that achieves
that by calling:

[source,clojure]
(defattrs :bg-green {:fill "#a0ffa0"})

From then on, you can use `:bg-green` in any attribute expression to
stand in for this fill color.


[[draw-bottom]]
== draw-bottom

Close the bottom of a gap drawn by `draw-gap`.

.Arguments
_none_

This function isn’t needed if you are continuing to draw enough boxes
after your gap to span an entire row, because the top borders of those
boxes will draw the bottom of the gap. But if your diagram ends after
the gap, or after a partial row after the gap, you will want to call
`(draw-bottom`) to draw the line across the bottom of the gap.

This isn’t done automatically because some diagrams want the gap to
extend into some of the boxes of the line after the gap, which can be
achieved by setting those boxes to not have a top border, but that
only works if the gap doesn’t close itself.


[[draw-box]]
== draw-box

This is probably the most-used function in `bytefield-svg`. It draws
the next cell in your byte field diagram.

If the previous box completed a row, drawing this new box will advance
to the start of the next row, and draw the row header.

.Arguments
[source,clojure]
----
[label]
[label attr-spec]
----

If you call `draw-box` with just a `label`, it will draw a box with a
default set of attributes that contains that label. If you want to
change the way the box is drawn, you can pass an
<<attrs#attribute-expressions,attribute expression>> as the second
argument <<draw-box-attrs,(see below)>>.

=== Label Styles

If you don’t want a label in the box, you can pass `nil` for `label`.

If you pass a string, it is rendered as <<text,text>>, as if you had
passed the result of calling `(text label)`.

If you pass a number, it is rendered in hexadecimal, with enough
digits to represent all the bytes spanned by your box (see the
discussion of the `:span` attribute below).

If you need a label with more complex structure or styling you can
build it by calling <<text,`text`>> or <<hex-text,`hex-text`>>
yourself and passing the results as `label`.

Or you can draw arbitrary SVG content in the box by passing a custom
label function as `label`. Your function will be called with four
arguments, the left and top coordinates of the box, and its width and
height. (This is one situation where you might use
<<append-svg,`append-svg`>>.)

This example uses a custom label function to draw two lines in the
box, from the top left to the bottom right, and the top right to the
bottom left:

[source,clojure]
(draw-box (fn [left top width height]
            (draw-line left top (+ left width) (+ top height))
            (draw-line left (+ top height) (+ left width) top)))

And here’s what it looks like repeated over a four-box row:

[bytefield]
----
(def boxes-per-row 4)
(def left-margin 1)
(draw-column-headers)
(doseq [_ (range 4)]
  (draw-box (fn [left top width height]
              (draw-line left top (+ left width) (+ top height))
              (draw-line left (+ top height) (+ left width) top))))
----

[[draw-box-attrs]]
=== Box Attributes

You can modify the box that is drawn by passing in the following
attributes:

[cols="1m,2m,6"]
|===
|Attribute |Default Value |Meaning

|:borders |#{:left :right :top :bottom} |Controls which box borders
 are drawn, and optionally, their individual attributes.
 <<draw-box-borders,See below>> for more details.

|:fill |nil |The fill color to use as the box background.

|:height |row-height |If you pass a value here you can override the
 height of the box. Normally it is controlled by the
 <<values#,predefined value>> `row-height`.

|:span |1 |The number of bytes (columns) this box will occupy. You can
 supply a `:span` value ranging from 1 to the remaining columns in
 the row. If you try to go beyond the end of the row, an exception
 will be thrown.
|===

Here are some sample boxes:

[source,clojure]
(draw-box 1)
(draw-box "two" {:span 2})
(draw-box nil {:fill "#a0ffa0"})

[bytefield]
----
(draw-box 1)
(draw-box "two" {:span 2})
(draw-box nil {:fill "#a0ffa0"})
----

And as a concrete example of how we can use <<defattrs,`defattrs`>> to
set up a named attribute making it concise to use later:

[source,clojure]
(defattrs :bg-blue {:fill "#80a0ff"})
(draw-box "b" :bg-blue)

[bytefield]
----
(defattrs :bg-blue {:fill "#80a0ff"})
(draw-box "b" :bg-blue)
----

When the keyword `:bg-blue` is found as a standalone attribute
expression, it is looked up in the named attribtues, and the fill that
we set up with `defattrs` is found and used.


[[draw-box-borders]]
=== Box Borders

As noted above, by default a box is drawn with all four borders (left,
right, top, and bottom). To change that, you can pass a Clojure
https://clojure.org/reference/reader#_sets[set] containing a subset of
the keywords `:left`, `:right`, `:top`, and `:bottom`, and only the
borders that you include will be drawn.

If you want even more control, rather than a set you can pass a
`:map`, whose keys are the keywords identifying the borders that you
want to draw, and whose values are
<<attrs#attribute-expressions,attribute expressions>> containing the
https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute[SVG
attributes] that describe the color and style of line that you want
that border to be drawn with. There are
<<attrs#predefined-attributes,predefined attributes>> that can be
useful here. Individual borders can be assigned line styles
`:border-unrelated` (the default) `:dotted`, and `:border-related`.

The entire border style of the box can be assigned more compactly
using the predefined styles `:box-first`, `:box-related`, `:box-last`,
`:box-above`, `:box-above-related`, or `:box-below`. Or of course you
can make up your own completely original line styles and border maps.

Here’s a look at the three line styles (with no bottom border):
[source,clojure]
----
(draw-box "borders"
          {:span    4
           :borders {:top   :dotted
                     :left  :border-related
                     :right :border-unrelated}})
----

[bytefield]
----
(draw-box "borders" {:span 4
                     :borders {:top  :dotted
                               :left  :border-related
                               :right :border-unrelated}})
----

> The same result could have been achieved by using the style map
`{:stroke-dasharray "1,1"}` instead of the predefined attribute
`:dotted` (that is its value), and `{:stroke-dasharray "1,3"}` instead
of the predefined attribute `:related`, but the short keywords are
both easier to type than the full maps, and easier to read and
understand than the raw SVG attributes.

And here’s an example of using the predefined attributes that specify
entire box border styles (notice how we can use the
<<attrs#attribute-expressions,attribute expression mini-language>> to
combine the border style named attributes with our own `:span`
attribute):

[source,clojure]
(draw-box "first" [:box-first {:span 3}])
(draw-box "related" [:box-related {:span 3}])
(draw-box "last" [:box-related {:span 3}])

[bytefield]
----
(draw-box "first" [:box-first {:span 3}])
(draw-box "related" [:box-related {:span 3}])
(draw-box "last" [:box-last {:span 3}])
----

[[draw-boxes]]
== draw-boxes

This is a shortcut for drawing mutiple labels with the same attributes
for each. It calls <<draw-box,`draw-box`>> for each value in `labels`.

.Arguments
[source,clojure]
----
[labels]
[labels attr-spec]
----

If you pass `attr-spec` it will be used when calling `draw-box` for
each value in `labels`. See the <<draw-box,`draw-box` documentation>>
for details about how labels and attributes are used to control the
drawing of each box.


[[draw-column-headers]]
== draw-column-headers

Draws the row of byte offsets at the top of the diagram, making it
easy to visually determine the addresses of boxes below. This is not
done until you ask for it, to give you an opportunity to first adjust
<<values#,predefined values>> that will affect the result.

.Arguments
[source,clojure]
----
[]
[attr-spec]
----

If you supply `attr-spec`, it is parsed as an
<<attrs#attribute-expressions,attribute expression>> that you can use
to further customize the column headers (in ways that don’t affect the
structure of the rest of the diagram):

=== Column Header Attributes

[cols="2m,2m,6"]
|===
|Attribute |Default Value |Meaning

|:font-family |"Courier New, monospace" |The typeface used to draw the
 column headers.

|:font-size |11 |Controls the size of the column headers.

|:height |14 |The amount of vertical space allocated to the column
 headers.

|:labels |<<values#column-labels,column-labels>> |A sequence whose
 elements are used as the actual text of each column header in order.
 You might want to change this if you are drawing a bit field, where
 the high order bits come first, as shown in the examples below.
|===

With no redefinitions of predefined values and no attribute
expression, this generates headers for a row of sixteen bytes as
hexadecimal digits:

[source,clojure]
(draw-column-headers)

[bytefield]
----
(draw-column-headers)
----

If you are dealing with big-endian values, you can reverse the
`column-labels` predefined value that is used to generate the
labels, and pass it in as the `:labels` attribute:

[source,clojure]
(draw-column-headers {:labels (reverse column-labels)})

[bytefield]
----
(draw-column-headers {:labels (reverse column-labels)})
----

If you want to draw a diagram with fewer columns, redefine
`boxes-per-row` before calling this:

[source,clojure]
(def boxes-per-row 8)
(draw-column-headers)

[bytefield]
----
(def boxes-per-row 8)
(draw-column-headers)
----

But note that if you want to both reduce the number of columns _and_
reverse the headers, you need to do a little more than combining these
two steps, because that simple approach results in the following
headers:

[source,clojure]
(def boxes-per-row 8)
(draw-column-headers {:labels (reverse column-labels)})

[bytefield]
----
(def boxes-per-row 8)
(draw-column-headers {:labels (reverse column-labels)})
----

...Which makes sense, if you think about it: there are sixteen values
in `column-labels`, so reversing it gives you the top eight. Luckily
the solution is straightforward, just use the
https://clojuredocs.org/clojure.core/take[Clojure’s `take`] function
to get the first eight labels _before_ calling `reverse`:

[source,clojure]
(def boxes-per-row 8)
(draw-column-headers {:labels (reverse (take 8 column-labels))})

[bytefield]
----
(def boxes-per-row 8)
(draw-column-headers {:labels (reverse (take 8 column-labels))})
----


[[draw-gap]]
== draw-gap

Draws an indication of discontinuity. Takes a full row (consuming the
rest of the current row first, if there have been any boxes drawn in
it). Also optionally labels the contents of the gap.

.Arguments
[source,clojure]
----
[]
[label]
[label attr-spec]
----

If `label` is provided, draws it to identify the content of the gap.
If there are at least `:min-label-columns` (which defaults to 8, see
the attributes below) remaining on the current row, will center the
label in the remaining space on that row before drawing the gap.
Otherwise it will advance to the next row, draw the label centered on
the entire row, then draw the gap. `label` is passed to
<<draw-box,`draw-box`>>, so it is interpreted in the same way.

When finishing off the previous row, a box is drawn in the predefined
<<attrs#box-above,`box-above` style>>. You can change that by passing
different attributes under the `:box-above-style` key in your
<<attrs#attribute-expressions,attribute expression>> (the optional
second argument). For example, use `{:box-above-style
:box-above-related}` if the gap relates to the preceding box.

=== Gap Attributes

[cols="2m,1m,4"]
|===
|Attribute |Default Value |Meaning

|:edge |15 |The height of the sections before and after the gap
 drawing, which just draw the left and right edges of the diagram.

|:height |70 |The height of the gap context, which is sandwiched
 bewteen the edges and affects the slope of the gap within it, drawn
 from the top left of this section to the bottom right.

|:gap |10 |The height of the gap itself, the unenclosed space between
 the diagonal lines of the gap.

|:gap-style |:dotted |The line style to use in drawing the diagonal
 lines on either side of the actual gap.

|:box-above-style |:box-above |The box style to use when drawing a box
 to finish of a partial row before the gap, as described above.

|:min-label-columns |8 |As described above, the number of columns that
 must be available in the current row if the label is to be drawn
 in it.

|===

NOTE: In order to allow you to draw boxes that connect to the bottom
of the gap, no bottom border is drawn. If you have a full row of boxes
after it this doesn’t matter, as their top borders will close it off.
But if the diagram ends at the gap, or with an incomplete row after
it, you need to call `<<draw-bottom,(draw-bottom)`>> after you draw
the gap.

[source,clojure]
(draw-box "Stuff" {:span 4})
(draw-gap "A gap")
(draw-box "More stuff")
(draw-bottom)

[bytefield]
----
(draw-box "Stuff" {:span 2})
(draw-gap "A gap")
(draw-box "More stuff" {:span 4})
(draw-bottom)
----

After a gap, the actual addresses of subsequent rows are not known,
since the gap can vary in length. To reflect that, row headers after
that point are reset to _i+_`00` (meaning zero bytes past the end of
the gap) and grow from there. If you would like a different labeling
scheme you can replace the <<values#row-header-fn,`row-header-fn`
predefined value>>.


[[draw-line]]
== draw-line

Adds a line to the SVG being built up. This is used extensively by the
other functions here to draw the diagram, but you can use it yourself
to draw your own custom content, either in your diagram itself, or as
a part of a custom label function in <<draw-box,`draw-box`>>.

.Arguments
[source,clojure]
----
[x1 y1 x2 y2]
[x1 y1 x2 y2 attr-spec]
----

The four required arguments are the coordinates of the endpoints of
the line segment to be drawn. If those are the only arguments you
supply, the line will be drawn with a `:stroke-width` of `1` and a
`:stroke` of `#000000` (black). But you can override those (and other
https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute[SVG
attributes]) by passing an <<attrs#attribute-expressions,attribute
expression>> as the second argument.

[[draw-related-boxes]]
== draw-related-boxes

> TODO: Document

[[draw-row-header]]
== draw-row-header

> TODO: Document

[[eval-attribute-spec]]
== eval-attribute-spec

> TODO: Document


[[hex-text]]
== hex-text

> TODO: Document


[[next-row]]
== next-row

> TODO: Document


[[text]]
== text

> TODO: Document


[[tspan]]
== tspan

> TODO: Document


include::partial$Footer.adoc[]
